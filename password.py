#!/usr/bin/env python
# -*- coding: utf-8
#
# The MIT License (MIT)
#
# Copyright (c) 2016 betriebsrat
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# password.py
# This module allows you to dynamically generate mumble server passwords
#

import re
import uuid
from threading import Timer

from mumo_module import MumoModule, commaSeperatedBool, commaSeperatedIntegers


class password(MumoModule):
    default_config = {'password': (
        ('servers', commaSeperatedIntegers, []),
    ),
        lambda x: re.match('(all)|(server_\d+)', x): (
            ('welcometext', str, 'Welcome to Mumble'),
            ('genpassword', str, '!pass'),
            ('delpassword', str, '!clearpass'),
            ('interval', int, 1800),
    )
    }

    def __init__(self, name, manager, configuration=None):
        MumoModule.__init__(self, name, manager, configuration)
        self.murmur = manager.getMurmurModule()
        self.watchdog = None

    def sendMessage(self, server, user, message, msg):
        server.sendMessage(user.session, msg)

    def cleartoken(self):
        cfg = self.cfg()
        log = self.log()
        try:
            meta = self.manager().getMeta()

            if not cfg.password.servers:
                servers = meta.getBootedServers()
            else:
                servers = [meta.getServer(server)
                           for server in cfg.password.servers]

            for server in servers:
                if not server:
                    continue

                if server:
                    try:
                        scfg = getattr(self.cfg(), 'server_%d' %
                                       int(server.id()))
                    except AttributeError:
                        scfg = self.cfg().all
                server.setConf("password", uuid.uuid4().hex[:24])
                server.setConf("welcometext", cfg.all.welcometext)
                log.debug("Serverpassword cleared after 30minutes.")
        except:
            pass

    def connected(self):
        manager = self.manager()
        log = self.log()
        cfg = self.cfg()
        log.debug("Register for Server callbacks")

        servers = self.cfg().password.servers
        if not servers:
            servers = manager.SERVERS_ALL

        manager.subscribeServerCallbacks(self, servers)

        if not self.watchdog:
            self.watchdog = Timer(cfg.all.interval, self.cleartoken)
            self.watchdog.start()

    def disconnected(self):
        if self.watchdog:
            self.watchdog.stop()
            self.watchdog = None

    # --- Server callback functions
    #

    def userTextMessage(self, server, user, message, current=None):
        log = self.log()
        cfg = self.cfg()
        try:
            scfg = getattr(self.cfg(), 'server_%d' % server.id())
        except AttributeError:
            scfg = self.cfg().all

        # Only allow registered Users to use command
        if user.userid > 0:
            if message.text.startswith(scfg.delpassword):
                msg = "Password cleared"
                self.sendMessage(server, user, message, msg)
                self.cleartoken()

            if message.text.startswith(scfg.genpassword):
                token = uuid.uuid4().hex[:12]
                server.setConf("password", token)
                server.setConf("welcometext",
                               cfg.all.welcometext + ", the current server password is: \"%s\" , it will expire in 30 minutes.\n Generated by %s" % (token, user.name))
                log.debug("A new serverpassword got generated by %s" %
                          user.name)
                # refresh timer
                self.watchdog = Timer(scfg.interval, self.cleartoken)
                self.watchdog.start()

    def userConnected(self, server, state, context=None):
        pass

    def userDisconnected(self, server, state, context=None):
        pass

    def userStateChanged(self, server, state, context=None):
        pass

    def channelCreated(self, server, state, context=None):
        pass

    def channelRemoved(self, server, state, context=None):
        pass

    def channelStateChanged(self, server, state, context=None):
        pass
